# Paxos 算法

#### 1. 一致性算法

Paxos 是一种基于消息传递且具有高度容错性的**一致性算法(共识算法)**,是目前公认的解决分布式一致性问题最有效地算法之一.

Paxos 算法需要解决的问题就是在一个可能发生上述异常的分布式系统中,快速且正确地在集群内部对某个数据的值达成一致,并且保证不论发生以上任何异常,都不

会破坏这个系统的一致性.



**Lamport** 论文

- The Part-Time Parliament
- Paxos Made Simple



**Lamport 提出的假设需要用来解决分布式一致性问题的场景:**

在古希腊有一个叫做 Paxos 的小岛,岛上采用议会的形式来通过法令,议会中的议员通过信使进行消息的传递.值得注意的是,议员和信使都是兼职的,他们随时有可能

会离开议会停,并且信使可能会重复的传递消息,也可能一去不复返.因此,议会要保证在这种情况下法令仍然能够正确的产生,并且不会出现冲突.



**问题描述**

假设有一组可以提出提案的进程集合, 南无对于一个一致性算法来说需要保证以下几点:

- 在这些被提出的提案中,只有一个会被选定.
- 如果没有提案被提出, 那么就不会有被选定的提案.
- 当一个提案被选定后,进程应该可以获取被选定的提案信息.

对于一致性来说, 安全性 (Safety) 需求如下:

- 只有被提出的提案才能被选定  (chosen).
- 只能有一个值被选定.
- 如果某个进程认为某个提案被选定了,那么这个提案必须是真的被选定的那个.

从整体上来说, Paxos 算法的目标就是要保证最终有一个提案会被选定, 当提案被选定后, 进程最终也能获取到被选定的提案.



**提案的选定**

Proposer 向一个 Acceptor 集合发送提案,同样,集合中的每个 Acceptor 都可能会批准 (Accept) 该提案, 当有足够多的 Acceptor 批准(**超过半数, 多数派原则**)这个提案的时候,我们就可以认为该提案被选定了.



**推导过程**

**P1**: 一个 Acceptor 必须批准它收到的第一个提案.

**P2**: 如果编号为 M0, Value 值为 V0 的提案 (即 [M0,V0]) 被选定了,那么所有比编号 M0 更高的, 且被选定的提案,其 Value 值必须也是 V0.

**P2a**: 如果编号为 M0, Value 值为 V0 的提案 (即 [M0, V0]) 被选定了, 那么所有比编号 M0 更高的, 且被 Acceptor 批准的提案, 其 Value 值必须是 V0.

**P2b**: 如果一个提案 [M0,V0]被选定后, 那么之后任何 Proposer 产生的编号更高的提案, 其 Value 值都为 V0.

**P2c**: 对于任意的 Mn 和 Vn, 如果提案 [Mn, Vn] 被提出, 那么肯定会存在一个由半数以上的 Acceptor 组成的集合 S, 满足以下两个条件中的任意一个:

- S 中不存在任何批准过编号小于 Mn 的提案的 Acceptor.
- 选取 S 中所有 Acceptor 批准的编号小于 Mn 的提案, 其中编号最大的那个提案其 Value 值是 Vn.

实际上 **P2c**  规定了每个 Proposer 如何产生一个提案: 队友产生的每个提案 [Mn, Vn], 需要满足如下条件.

存在一个由超过半数的 Acceptor 组成的集合 S:

- 要么 S 中没有 Acceptor 批准过编号小于 Mn 的任何提案.
- 要么 S 中 的所有 Acceptor 批准的所有编号小于 Mn 的提案中,编号最大的那个提案的 Value 值为 Vn.



**Proposer 生成提案**

1. Proposer 选择一个新的提案编号 Mn, 然后向某个 Acceptor 集合的成员发送请求,要求该集合中的 Acceptor 做出如下回应.

    - 向 Proposer 承诺保证不再批准任何编号小于 Mn 的提案.
    - 如果 Acceptor 已经批准过任何提案,那么其就向 Proposer 反馈当前该 Acceptor 已经批准的编号小于 Mn 但为最大编号的那个提案的值.

2. 如果 Proposer 收到了来自半数以上的 Acceptor 的响应结果,那么它就可以产生编号为 Mn, Value 值为 Vn 的提案,这里的 Vn 是所有响应中编号最大的提案的Value 值. 或者半数以上的 Acceptor 都没有批准过任何提案,即响应中不包含任何的提案,那么此时 Vn 值就可以有 Proposer 任意选择

    

**Acceptor 批准提案**

Prepare 请求: Acceptor 可以在任何时候响应一个 prepare 请求.

Accept 请求: 在不违背 Accept 现有承诺的前提下,可以任意响应 Accept 请求.

**P1a**: 一个 Acceptor 只要尚未响应过任何编号大于 Mn 的 Prepare 请求, 那么它就可以接口这个编号为 Mn 的提案.



**算法陈述**

**阶段一**

1. Proposer 选择一个提案编号 Mn, 然后向 Acceptor 的某个超过半数的子集集合发送编号为 Mn 的 Prepare 请求.

2. 如果一个 Acceptor 收到一个编号为 Mn 的 Prepare 请求, 且编号 Mn 大于该 Acceptor 已经响应过的所有 Prepare 请求的编号,那么它就会将它已经批准的最

    大编号的提案作为响应反馈给 Proposer,同时该 Acceptor 会承诺不再批准任何编号小于 Mn 的提案.



**阶段二**

1. 如果 Proposer 收到来自半数以上的 Acceptor 对于其发出的编号为 Mn 的 Prepare 请求的响应,那么它就会发送一个针对 [Mn,Vn] 提案的Acceptor 请求给 

    Acceptor. 注意, Vn 的值就是收到的响应中编号最大的提案的值, 如果响应中不包含任何提案, 那么它就是任意值.

2. 如果 Acceptor 收到这个针对 [Mn, Vn] 提案的 Accept 请求, 只要该 Acceptor 尚未对编号大于 Mn 的 Prepare 的请求做出响应, 它就可以通过这个提案.



**Learner 提案的获取**

**方案一**

通过了提案的 Acceptor 将提案发送给所有的 Learner.

**方案二**

通过了提案的 Acceptor 将提案发送给**主 Learner**.

**方案三**

通过了提案的 Acceptor 将提案发送给**主 Learner 集合**.



![paxos算法](D:%5Cnote%5Czookeeper%5Cpaxos%E7%AE%97%E6%B3%95.png)