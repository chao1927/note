# 1. Redis 数据结构

### 1. 简单动态字符串 (SDS)

1. 定义

![redis字符串-SDS](D:%5Cnote%5Credis%5Credis%E5%AD%97%E7%AC%A6%E4%B8%B2-SDS-1617030279886.png)

在 Redis 的数据库中，包含：

1. 字符串值的键值对在底层都是由 SDS 实现。
2. SDS 还被作为缓存区 (buffer)，AOF 模块中的 AOF 缓存区。
3. 客户端状态中的输入缓存区。

```c
struct sdshdr {
    
	// 记录 buf 数组中已使用的字节数量， 等于 SDS 所保存的字符串的长度
    int len;
    
    // 记录 buf 数组中未使用字节的数量
    int free;
    
    // 字节数组，用于保存字符串
    char buf[];
}
```

> 注意：SDS 遵循 C 字符串以空字符结尾的惯例，保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面，并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末尾等操作，都是由 SDS 函数自动完成的，所以这个空字符串对于 SDS 的使用者来说是完全透明的。

2. ##### 与 C 字符串的对比

1. **常数复杂度获取字符串的长度，通过 len 直接获取字符串长度**
2. **杜绝缓存区溢出，使用柔性数组，动态分配字符数组空间**

当 SDS API 需要对 SDS 进行修改时，API 会先检查 SDS 的空间是否满足修改所需的要求，如果不满足的话，SDS 会使用空间预分配策略，API 会自动将 SDS 地空

间扩展至执行修改所需的大小，这样也可以减少修改字符串时带来的内存重分配次数。

- 当 SDS 长度小于 1 MB，那么扩展至当前 len 所需长度的两倍
- 当 SDS 长度大于等于 1MB，那么扩展 1 MB

另外，当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录下来，

并等待将来使用，采用惰性空间释放的策略，避免 SDS 缩短字符串时所需的内存重分配操作，也为未来增长做了优化。

3. **二进制安全**

SDS 对 buf 的内容都是以二进制处理方式来处理，避免了 C 字符串不能包含空字符串所带来的末尾不能包含空字符的限制。

4. **兼容部分 C 字符串函数**



#### 3. 常见简单动态字符串结构

1. **sdshdr5**

![Redis简单动态字符串-sdshdr5](D:%5Cnote%5Credis%5CRedis%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-sdshdr5.png)



2. **sdshdr16**

![Redis简单动态字符串-sdshdr16](D:%5Cnote%5Credis%5CRedis%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-sdshdr16.png)